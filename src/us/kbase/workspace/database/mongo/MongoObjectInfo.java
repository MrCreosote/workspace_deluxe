package us.kbase.workspace.database.mongo;

import java.util.Collections;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

import us.kbase.workspace.database.ObjectInformation;
import us.kbase.workspace.database.Reference;
import us.kbase.workspace.database.UncheckedUserMetadata;
import us.kbase.workspace.database.WorkspaceUser;

/** A MongoDB oriented implementation of ObjectInformation.
 * @author gaprice@lbl.gov
 *
 */
public class MongoObjectInfo implements ObjectInformation {
	
	final private long id;
	final private String name;
	final private String type;
	final private Date savedDate;
	final private int version;
	final private WorkspaceUser savedBy;
	final private long workspaceID;
	final private String workspaceName;
	final private String chksum;
	final private long size;
	final private UncheckedUserMetadata meta;
	final private List<Reference> refpath;
	
	/** Create a new MongoObjectInfo.
	 * @param id the object id.
	 * @param name the object name.
	 * @param typeString the absolute type of the object as a string.
	 * @param savedDate the date the object was saved or copied.
	 * @param version the version of the object.
	 * @param savedBy the user that saved or copied the object.
	 * @param workspaceID the resolved workspace identifier containing the object.
	 * @param chksum the md5 checksum of the object when serialized to a JSON string with sorted
	 * keys.
	 * @param size the size of the object when serialized to a JSON string.
	 * @param meta the user provided and autogenerated metadata for the object.
	 */
	MongoObjectInfo(
			final long id,
			final String name,
			final String typeString,
			final Date savedDate,
			final int version,
			final WorkspaceUser savedBy,
			final ResolvedMongoWSID workspaceID,
			final String chksum,
			final long size,
			final UncheckedUserMetadata meta) {
		//no error checking for now, add if needed
		this.id = id;
		this.name = name;
		this.type = typeString;
		this.savedDate = savedDate;
		this.version = version;
		this.savedBy = savedBy;
		this.workspaceID = workspaceID.getID();
		this.workspaceName = workspaceID.getName();
		this.chksum = chksum;
		this.size = size;
		this.meta = meta;
		final List<Reference> refs = new LinkedList<>();
		refs.add(new Reference(workspaceID.getID(), id, version));
		this.refpath = Collections.unmodifiableList(refs);
	}
	
	private MongoObjectInfo(
			final long id,
			final String name,
			final String typeString,
			final Date savedDate,
			final int version,
			final WorkspaceUser savedBy,
			final long workspaceID,
			final String workspaceName,
			final String chksum,
			final long size,
			final UncheckedUserMetadata meta,
			final List<Reference> refpath) {
		//no error checking for now, add if needed
		this.id = id;
		this.name = name;
		this.type = typeString;
		this.savedDate = savedDate;
		this.version = version;
		this.savedBy = savedBy;
		this.workspaceID = workspaceID;
		this.workspaceName = workspaceName;
		this.chksum = chksum;
		this.size = size;
		this.meta = meta;
		this.refpath = refpath;
	}

	@Override
	public long getObjectId() {
		return id;
	}

	@Override
	public String getObjectName() {
		return name;
	}

	@Override
	public String getTypeString() {
		return type;
	}

	@Override
	public Date getSavedDate() {
		return savedDate;
	}

	@Override
	public int getVersion() {
		return version;
	}

	@Override
	public WorkspaceUser getSavedBy() {
		return savedBy;
	}

	@Override
	public long getWorkspaceId() {
		return workspaceID;
	}
	
	@Override
	public String getWorkspaceName() {
		return workspaceName;
	}

	@Override
	public String getCheckSum() {
		return chksum;
	}
	
	
	@Override
	public long getSize() {
		return size;
	}
	
	@Override
	public UncheckedUserMetadata getUserMetaData() {
		return meta;
	}

	@Override
	public List<Reference> getReferencePath() {
		return refpath;
	}

	@Override
	public ObjectInformation updateReferencePath(final List<Reference> refpath) {
		if (refpath == null || refpath.isEmpty()) {
			throw new IllegalArgumentException("refpath cannot be null or empty");
		}
		//TODO CODE look into eliminating all the DB implementation specific classes, too much of a pain just to ensure not moving refs between implementations
		// Use ID rather than equals so different reference implementations count as equal
		if (!getLast(refpath).getId().equals(getLast(this.refpath).getId())) {
			throw new IllegalArgumentException(
					"refpath must end with the same reference as the current refpath");
		}
		return new MongoObjectInfo(id, name, type, savedDate, version, savedBy, workspaceID,
				workspaceName, chksum, size, meta, refpath);
	}
	
	private Reference getLast(final List<Reference> refpath) {
		return refpath.get(refpath.size() - 1);
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("MongoObjectInfo [id=");
		builder.append(id);
		builder.append(", name=");
		builder.append(name);
		builder.append(", type=");
		builder.append(type);
		builder.append(", savedDate=");
		builder.append(savedDate);
		builder.append(", version=");
		builder.append(version);
		builder.append(", savedBy=");
		builder.append(savedBy);
		builder.append(", workspaceId=");
		builder.append(workspaceID);
		builder.append(", workspaceName=");
		builder.append(workspaceName);
		builder.append(", chksum=");
		builder.append(chksum);
		builder.append(", size=");
		builder.append(size);
		builder.append(", meta=");
		builder.append(meta);
		builder.append(", refpath=");
		builder.append(refpath);
		builder.append("]");
		return builder.toString();
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((chksum == null) ? 0 : chksum.hashCode());
		result = prime * result + (int) (id ^ (id >>> 32));
		result = prime * result + ((meta == null) ? 0 : meta.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + ((refpath == null) ? 0 : refpath.hashCode());
		result = prime * result + ((savedBy == null) ? 0 : savedBy.hashCode());
		result = prime * result + ((savedDate == null) ? 0 : savedDate.hashCode());
		result = prime * result + (int) (size ^ (size >>> 32));
		result = prime * result + ((type == null) ? 0 : type.hashCode());
		result = prime * result + version;
		result = prime * result + (int) (workspaceID ^ (workspaceID >>> 32));
		result = prime * result + ((workspaceName == null) ? 0 : workspaceName.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		MongoObjectInfo other = (MongoObjectInfo) obj;
		if (chksum == null) {
			if (other.chksum != null) {
				return false;
			}
		} else if (!chksum.equals(other.chksum)) {
			return false;
		}
		if (id != other.id) {
			return false;
		}
		if (meta == null) {
			if (other.meta != null) {
				return false;
			}
		} else if (!meta.equals(other.meta)) {
			return false;
		}
		if (name == null) {
			if (other.name != null) {
				return false;
			}
		} else if (!name.equals(other.name)) {
			return false;
		}
		if (refpath == null) {
			if (other.refpath != null) {
				return false;
			}
		} else if (!refpath.equals(other.refpath)) {
			return false;
		}
		if (savedBy == null) {
			if (other.savedBy != null) {
				return false;
			}
		} else if (!savedBy.equals(other.savedBy)) {
			return false;
		}
		if (savedDate == null) {
			if (other.savedDate != null) {
				return false;
			}
		} else if (!savedDate.equals(other.savedDate)) {
			return false;
		}
		if (size != other.size) {
			return false;
		}
		if (type == null) {
			if (other.type != null) {
				return false;
			}
		} else if (!type.equals(other.type)) {
			return false;
		}
		if (version != other.version) {
			return false;
		}
		if (workspaceID != other.workspaceID) {
			return false;
		}
		if (workspaceName == null) {
			if (other.workspaceName != null) {
				return false;
			}
		} else if (!workspaceName.equals(other.workspaceName)) {
			return false;
		}
		return true;
	}

}
