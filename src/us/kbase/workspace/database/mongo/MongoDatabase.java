package us.kbase.workspace.database.mongo;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.lang3.StringUtils;
import org.jongo.FindAndModify;
import org.jongo.Jongo;
import org.jongo.MongoCollection;
import org.jongo.marshall.MarshallingException;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.experimental.runners.Enclosed;

import us.kbase.typedobj.core.AbsoluteTypeDefId;
import us.kbase.typedobj.core.TypeDefName;
import us.kbase.typedobj.core.TypeDefId;
import us.kbase.typedobj.core.TypedObjectValidator;
import us.kbase.typedobj.db.TypeDefinitionDB;
import us.kbase.typedobj.db.MongoTypeStorage;
import us.kbase.typedobj.db.UserInfoProviderForTests;
import us.kbase.workspace.database.AllUsers;
import us.kbase.workspace.database.Database;
import us.kbase.workspace.database.ObjectIDResolvedWS;
import us.kbase.workspace.database.ObjectIDResolvedWSNoVer;
import us.kbase.workspace.database.ObjectMetaData;
import us.kbase.workspace.database.ObjectUserMetaData;
import us.kbase.workspace.database.Permission;
import us.kbase.workspace.database.ResolvedWorkspaceID;
import us.kbase.workspace.database.User;
import us.kbase.workspace.database.WorkspaceIdentifier;
import us.kbase.workspace.database.WorkspaceMetaData;
import us.kbase.workspace.database.WorkspaceObjectData;
import us.kbase.workspace.database.WorkspaceObjectID;
import us.kbase.workspace.database.WorkspaceUser;
import us.kbase.workspace.database.exceptions.CorruptWorkspaceDBException;
import us.kbase.workspace.database.exceptions.DBAuthorizationException;
import us.kbase.workspace.database.exceptions.InvalidHostException;
import us.kbase.workspace.database.exceptions.NoSuchObjectException;
import us.kbase.workspace.database.exceptions.NoSuchWorkspaceException;
import us.kbase.workspace.database.exceptions.PreExistingWorkspaceException;
import us.kbase.workspace.database.exceptions.UninitializedWorkspaceDBException;
import us.kbase.workspace.database.exceptions.WorkspaceCommunicationException;
import us.kbase.workspace.database.exceptions.WorkspaceDBException;
import us.kbase.workspace.database.exceptions.WorkspaceDBInitializationException;
import us.kbase.workspace.database.mongo.exceptions.BlobStoreAuthorizationException;
import us.kbase.workspace.database.mongo.exceptions.BlobStoreCommunicationException;
import us.kbase.workspace.database.mongo.exceptions.BlobStoreException;
import us.kbase.workspace.database.mongo.exceptions.NoSuchBlobException;
import us.kbase.workspace.test.WorkspaceTestCommon;
import us.kbase.workspace.workspaces.Provenance;
import us.kbase.workspace.workspaces.ResolvedSaveObject;
import us.kbase.workspace.workspaces.WorkspaceSaveObject;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCursor;
import com.mongodb.DBObject;
import com.mongodb.MongoClient;
import com.mongodb.MongoClientOptions;
import com.mongodb.MongoException;

@RunWith(Enclosed.class)
public class MongoDatabase implements Database {

	//TODO handle hidden objects - changes most methods
	//TODO query user metadata
	//TODO save set of objects with same provenance if they were generated by same fn
	
	private static final String COL_SETTINGS = "settings";
	private static final String COL_WS_CNT = "workspaceCounter";
	private static final String COL_WORKSPACES = "workspaces";
	private static final String COL_WS_ACLS = "workspaceACLs";
	private static final String COL_WORKSPACE_PTRS = "workspacePointers";
	private static final String COL_SHOCK = "shockData";
	private static final User allUsers = new AllUsers('*');
	
	private static MongoClient MONGO_CLIENT = null;
	private final DB wsmongo;
	private final Jongo wsjongo;
	private final BlobStore blob;
	private final QueryMethods query;
	private final FindAndModify updateWScounter;
	private final TypedObjectValidator typeValidator;
	
	private final Map<AbsoluteTypeDefId, Boolean> typeIndexEnsured = 
			new HashMap<AbsoluteTypeDefId, Boolean>();
	
	//TODO constants class

	private static final Map<String, Map<List<String>, List<String>>> INDEXES;
	private static final String IDX_UNIQ = "unique";
	private static final String IDX_SPARSE = "sparse";
	static {
		//hardcoded indexes
		INDEXES = new HashMap<String, Map<List<String>, List<String>>>();
		
		//workspaces indexes
		Map<List<String>, List<String>> ws = new HashMap<List<String>, List<String>>();
		//find workspaces you own
		ws.put(Arrays.asList(Fields.WS_OWNER), Arrays.asList(""));
		//find workspaces by permanent id
		ws.put(Arrays.asList(Fields.WS_ID), Arrays.asList(IDX_UNIQ));
		//find workspaces by mutable name
		ws.put(Arrays.asList(Fields.WS_NAME), Arrays.asList(IDX_UNIQ));
		INDEXES.put(COL_WORKSPACES, ws);
		
		//workspace acl indexes
		Map<List<String>, List<String>> wsACL = new HashMap<List<String>, List<String>>();
		//get a user's permission for a workspace, index covers queries
		wsACL.put(Arrays.asList(Fields.ACL_WSID, Fields.ACL_USER, Fields.ACL_PERM), Arrays.asList(IDX_UNIQ));
		//find workspaces to which a user has some level of permission, index coves queries
		wsACL.put(Arrays.asList(Fields.ACL_USER, Fields.ACL_PERM, Fields.ACL_WSID), Arrays.asList(""));
		INDEXES.put(COL_WS_ACLS, wsACL);
		
		//workspace pointer indexes
		Map<List<String>, List<String>> wsPtr = new HashMap<List<String>, List<String>>();
		//find objects by workspace id & name
		wsPtr.put(Arrays.asList(Fields.PTR_WS_ID, Fields.PTR_NAME), Arrays.asList(IDX_UNIQ));
		//find object by workspace id & object id
		wsPtr.put(Arrays.asList(Fields.PTR_WS_ID, Fields.PTR_ID,
				Fields.PTR_VERS + Fields.FIELD_SEP + Fields.PTR_VER_VER), Arrays.asList(IDX_UNIQ));
		//find objects by legacy UUID
		wsPtr.put(Arrays.asList(Fields.PTR_VERS + Fields.FIELD_SEP + Fields.PTR_VER_UUID),
				Arrays.asList(IDX_UNIQ, IDX_SPARSE));
		//determine whether a particular object references this object
		wsPtr.put(Arrays.asList(Fields.PTR_VERS + Fields.FIELD_SEP + Fields.PTR_VER_REF),
				Arrays.asList("")); //TODO this might be a bad idea
		//TODO deletion and creation dates for search?
		INDEXES.put(COL_WORKSPACE_PTRS, wsPtr);
	}

	public MongoDatabase(final String host, final String database,
			final String backendSecret) throws UnknownHostException,
			IOException, InvalidHostException, WorkspaceDBException {
		wsmongo = getDB(host, database);
		wsjongo = new Jongo(wsmongo);
		query = new QueryMethods(wsmongo, (AllUsers) allUsers, COL_WORKSPACES,
				COL_WORKSPACE_PTRS, COL_WS_ACLS);
		final Settings settings = getSettings();
		blob = setupBlobStore(settings, backendSecret);
		updateWScounter = buildCounterQuery(wsjongo);
		this.typeValidator = new TypedObjectValidator(
				new TypeDefinitionDB(
						new MongoTypeStorage(
								getDB(host, settings.getTypeDatabase())),
								new UserInfoProviderForTests()));
		ensureIndexes();
	}

	public MongoDatabase(final String host, final String database,
			final String backendSecret, final String user,
			final String password) throws UnknownHostException, IOException,
			DBAuthorizationException, WorkspaceDBException,
			InvalidHostException {
		wsmongo = getDB(host, database, user, password);
		wsjongo = new Jongo(wsmongo);
		query = new QueryMethods(wsmongo, (AllUsers) allUsers, COL_WORKSPACES,
				COL_WORKSPACE_PTRS, COL_WS_ACLS);
		final Settings settings = getSettings();
		blob = setupBlobStore(settings, backendSecret);
		updateWScounter = buildCounterQuery(wsjongo);
		this.typeValidator = new TypedObjectValidator(
				new TypeDefinitionDB(
						new MongoTypeStorage(
								getDB(host, settings.getTypeDatabase(), user, password)),
								new UserInfoProviderForTests()));
		ensureIndexes();
	}
	
	private void ensureIndexes() {
		for (String col: INDEXES.keySet()) {
			for (List<String> idx: INDEXES.get(col).keySet()) {
				final DBObject index = new BasicDBObject();
				final DBObject opts = new BasicDBObject();
				for (String field: idx) {
					index.put(field, 1);
				}
				for (String option: INDEXES.get(col).get(idx)) {
					if (!option.equals("")) {
						opts.put(option, 1);
					}
				}
				wsmongo.getCollection(col).ensureIndex(index, opts);
			}
		}
	}
	
	private void ensureTypeIndexes(final AbsoluteTypeDefId type) {
		if (typeIndexEnsured.containsKey(type)) {
			return;
		}
		String col = getTypeCollection(type);
		final DBObject chksum = new BasicDBObject();
		chksum.put(Fields.TYPE_CHKSUM, 1);
		final DBObject unique = new BasicDBObject();
		unique.put(IDX_UNIQ, 1);
		wsmongo.getCollection(col).ensureIndex(chksum, unique);
		final DBObject workspaces = new BasicDBObject();
		workspaces.put(Fields.TYPE_WS, 1);
		wsmongo.getCollection(col).ensureIndex(workspaces);
		typeIndexEnsured.put(type, true);
	}
	
	private static FindAndModify buildCounterQuery(final Jongo j) {
		return j.getCollection(COL_WS_CNT)
				.findAndModify(String.format("{%s: #}",
						Fields.CNT_ID), Fields.CNT_ID_VAL)
				.upsert().returnNew().with("{$inc: {" + Fields.CNT_NUM + ": 1}}")
				.projection(String.format("{%s: 1, %s: 0}",
						Fields.CNT_NUM, Fields.MONGO_ID));
	}
	
	//only the first call sets the host, host ignored for further calls
	private MongoClient getMongoClient(final String host) throws
			UnknownHostException, InvalidHostException {
		//Only make one instance of MongoClient per JVM per mongo docs
		if (MONGO_CLIENT == null) {
			// Don't print to stderr
			Logger.getLogger("com.mongodb").setLevel(Level.OFF);
			final MongoClientOptions opts = MongoClientOptions.builder()
					.autoConnectRetry(true).build();
			try {
				MONGO_CLIENT = new MongoClient(host, opts);
			} catch (NumberFormatException nfe) {
				throw new InvalidHostException(host
						+ " is not a valid mongodb host");
			}
		}
		return MONGO_CLIENT;
	}
	
	private DB getDB(final String host, final String database) throws
			UnknownHostException, InvalidHostException, IOException {
		final DB db = getMongoClient(host).getDB(database);
		try {
			db.getCollectionNames();
		} catch (MongoException.Network men) {
			throw (IOException) men.getCause();
		}
		return db;
	}
	
	private DB getDB(final String host, final String database,
			final String user, final String pwd) throws
			UnknownHostException, InvalidHostException, IOException,
			DBAuthorizationException {
		final DB db = getMongoClient(host).getDB(database);
		try {
			db.authenticate(user, pwd.toCharArray());
		} catch (MongoException.Network men) {
			throw (IOException) men.getCause();
		}
		try {
			db.getCollectionNames();
		} catch (MongoException me) {
			throw new DBAuthorizationException("Not authorized for database "
					+ database, me);
		}
		return db;
	}
	
	private Settings getSettings() throws UninitializedWorkspaceDBException,
			CorruptWorkspaceDBException {
		if (!wsmongo.collectionExists(COL_SETTINGS)) {
			throw new UninitializedWorkspaceDBException(
					"No settings collection exists");
		}
		MongoCollection settings = wsjongo.getCollection(COL_SETTINGS);
		if (settings.count() != 1) {
			throw new CorruptWorkspaceDBException(
					"More than one settings document exists");
		}
		Settings wsSettings = null;
		try {
			wsSettings = settings.findOne().as(Settings.class);
		} catch (MarshallingException me) {
			Throwable ex = me.getCause();
			if (ex == null) {
				throw new CorruptWorkspaceDBException(
						"Unable to unmarshal settings document", me);
			}
			ex = ex.getCause();
			if (ex == null || !(ex instanceof CorruptWorkspaceDBException)) {
				throw new CorruptWorkspaceDBException(
						"Unable to unmarshal settings document", me);
			}
			throw (CorruptWorkspaceDBException) ex;
		}
		return wsSettings;
	}

	private BlobStore setupBlobStore(final Settings settings,
			final String backendSecret) throws CorruptWorkspaceDBException,
			DBAuthorizationException, WorkspaceDBInitializationException {
		if (settings.isGridFSBackend()) {
			return new GridFSBackend(wsmongo);
		}
		if (settings.isShockBackend()) {
			URL shockurl = null;
			try {
				shockurl = new URL(settings.getShockUrl());
			} catch (MalformedURLException mue) {
				throw new CorruptWorkspaceDBException(
						"Settings has bad shock url: "
								+ settings.getShockUrl(), mue);
			}
			BlobStore bs;
			try {
				bs = new ShockBackend(wsmongo.getCollection(COL_SHOCK),
						shockurl, settings.getShockUser(), backendSecret);
			} catch (BlobStoreAuthorizationException e) {
				throw new DBAuthorizationException(
						"Not authorized to access the blob store database", e);
			} catch (BlobStoreException e) {
				throw new WorkspaceDBInitializationException(
						"The database could not be initialized: " +
						e.getLocalizedMessage(), e);
			}
			// TODO if shock, check a few random nodes to make sure they match
			// the internal representation, die otherwise
			return bs;
		}
		throw new RuntimeException("Something's real broke y'all");
	}
	
	@Override
	public TypedObjectValidator getTypeValidator() {
		return typeValidator;
	}

	@Override
	public String getBackendType() {
		return blob.getStoreType();
	}
	
	private static final String M_CREATE_WS_QRY = String.format("{%s: #}",
			Fields.WS_NAME);

	@Override
	public WorkspaceMetaData createWorkspace(final WorkspaceUser user,
			final String wsname, final boolean globalRead,
			final String description) throws PreExistingWorkspaceException,
			WorkspaceCommunicationException, CorruptWorkspaceDBException {
		//avoid incrementing the counter if we don't have to
		try {
			if (wsjongo.getCollection(COL_WORKSPACES).count(
					M_CREATE_WS_QRY, wsname) > 0) {
				throw new PreExistingWorkspaceException(String.format(
						"Workspace %s already exists", wsname));
			}
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
		Integer count; 
		try {
			count = (Integer) updateWScounter.as(DBObject.class)
					.get(Fields.CNT_NUM);
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
		final DBObject ws = new BasicDBObject();
		ws.put(Fields.WS_OWNER, user.getUser());
		ws.put(Fields.WS_ID, count);
		Date moddate = new Date();
		ws.put(Fields.WS_MODDATE, moddate);
		ws.put(Fields.WS_NAME, wsname);
		ws.put(Fields.WS_DEL, false);
		ws.put(Fields.WS_NUMPTR, 0);
		ws.put(Fields.WS_DESC, description);
		try {
			wsmongo.getCollection(COL_WORKSPACES).insert(ws);
		} catch (MongoException.DuplicateKey mdk) {
			//this is almost impossible to test and will probably almost never happen
			throw new PreExistingWorkspaceException(String.format(
					"Workspace %s already exists", wsname));
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
		setPermissionsForWorkspaceUsers(count, Arrays.asList(user),
				Permission.OWNER, false);
		if (globalRead) {
			setPermissions(count, Arrays.asList(allUsers), Permission.READ,
					false);
		}
		return new MongoWSMeta(count, wsname, user, moddate, Permission.OWNER,
				globalRead);
	}
	
	//projection lists
	private static final Set<String> FLDS_WS_DESC = newHashSet(Fields.WS_DESC);
	private static final Set<String> FLDS_PTR_ID = newHashSet(Fields.PTR_ID);
	private static final Set<String> FLDS_WS_ID_DEL =
			newHashSet(Fields.WS_ID, Fields.WS_DEL);
	private static final Set<String> FLDS_WS_OWNER = newHashSet(Fields.WS_OWNER);
	
	//http://stackoverflow.com/questions/2041778/initialize-java-hashset-values-by-construction
	@SafeVarargs
	private static <T> Set<T> newHashSet(T... objs) {
		Set<T> set = new HashSet<T>();
		for (T o : objs) {
			set.add(o);
		}
		return set;
	}
	
	@Override
	public String getWorkspaceDescription(final ResolvedWorkspaceID rwsi) throws
			CorruptWorkspaceDBException, WorkspaceCommunicationException {
		return (String) query.queryWorkspace(query.convertResolvedID(rwsi),
				FLDS_WS_DESC).get(Fields.WS_DESC);
	}
	
	@Override
	public ResolvedWorkspaceID resolveWorkspace(final WorkspaceIdentifier wsi)
			throws NoSuchWorkspaceException, WorkspaceCommunicationException {
		return resolveWorkspace(wsi, false);
	}
	
	@Override
	public ResolvedWorkspaceID resolveWorkspace(final WorkspaceIdentifier wsi,
			final boolean allowDeleted)
			throws NoSuchWorkspaceException, WorkspaceCommunicationException {
		Set<WorkspaceIdentifier> wsiset = new HashSet<WorkspaceIdentifier>();
		wsiset.add(wsi);
		return resolveWorkspaces(wsiset, allowDeleted).get(wsi);
				
	}
	
	@Override
	public Map<WorkspaceIdentifier, ResolvedWorkspaceID> resolveWorkspaces(
			final Set<WorkspaceIdentifier> wsis) throws NoSuchWorkspaceException,
			WorkspaceCommunicationException {
		return resolveWorkspaces(wsis, false);
	}
	
	@Override
	public Map<WorkspaceIdentifier, ResolvedWorkspaceID> resolveWorkspaces(
			final Set<WorkspaceIdentifier> wsis, final boolean allowDeleted)
			throws NoSuchWorkspaceException, WorkspaceCommunicationException {
		final Map<WorkspaceIdentifier, ResolvedWorkspaceID> ret =
				new HashMap<WorkspaceIdentifier, ResolvedWorkspaceID>();
		if (wsis.isEmpty()) {
			return ret;
		}
		final Map<WorkspaceIdentifier, Map<String, Object>> res =
				query.queryWorkspacesByIdentifier(wsis, FLDS_WS_ID_DEL);
		for (final WorkspaceIdentifier wsi: res.keySet()) {
			if (!allowDeleted && (boolean) res.get(wsi).get(Fields.WS_DEL)) {
				throw new NoSuchWorkspaceException("Workspace " +
						wsi.getIdentifierString() + " is deleted");
			}
			ResolvedMongoWSID r = new ResolvedMongoWSID(
					(Integer) res.get(wsi).get(Fields.WS_ID));
			ret.put(wsi, r);
		}
		return ret;
	}
	
	@Override
	public void setPermissions(final ResolvedWorkspaceID rwsi,
			final List<WorkspaceUser> users, final Permission perm) throws
			WorkspaceCommunicationException, CorruptWorkspaceDBException {
		setPermissionsForWorkspaceUsers(query.convertResolvedID(rwsi).getID(),
				users, perm, true);
	}
	
	//wsid must exist as a workspace
	private void setPermissionsForWorkspaceUsers(final int wsid,
			final List<WorkspaceUser> users, final Permission perm, 
			final boolean checkowner) throws WorkspaceCommunicationException,
			CorruptWorkspaceDBException {
		List<User> u = new ArrayList<User>();
		for (User user: users) {
			u.add(user);
		}
		setPermissions(wsid, u, perm, checkowner);
		
	}
	
	private static final String M_PERMS_QRY = String.format("{%s: #, %s: #}",
			Fields.ACL_WSID, Fields.ACL_USER);
	private static final String M_PERMS_UPD = String.format("{$set: {%s: #}}",
			Fields.ACL_PERM);
	
	//wsid must exist as a workspace
	private void setPermissions(final int wsid, final List<User> users,
			final Permission perm, final boolean checkowner) throws
			WorkspaceCommunicationException, CorruptWorkspaceDBException {
		final WorkspaceUser owner;
		if (checkowner) {
			try {
				owner = new WorkspaceUser((String) 
						query.queryWorkspace(wsid, FLDS_WS_OWNER)
						.get(Fields.WS_OWNER));
			} catch (NoSuchWorkspaceException nswe) {
				throw new CorruptWorkspaceDBException(String.format(
						"Workspace %s was deleted from the database", wsid));
			}
		} else {
			owner = null;
		}
		for (User user: users) {
			if (owner != null && owner.getUser().equals(user.getUser())) {
				continue; // can't change owner permissions
			}
			try {
				if (perm.equals(Permission.NONE)) {
					wsjongo.getCollection(COL_WS_ACLS).remove(
							M_PERMS_QRY, wsid, user.getUser());
				} else {
					wsjongo.getCollection(COL_WS_ACLS).update(
							M_PERMS_QRY, wsid, user.getUser())
							.upsert().with(M_PERMS_UPD, perm.getPermission());
				}
			} catch (MongoException me) {
				throw new WorkspaceCommunicationException(
						"There was a problem communicating with the database", me);
			}
		}
	}
	
	@Override
	public Permission getPermission(final WorkspaceUser user,
			final ResolvedWorkspaceID wsi) throws 
			WorkspaceCommunicationException, CorruptWorkspaceDBException {
		final Set<ResolvedWorkspaceID> wsis =
				new HashSet<ResolvedWorkspaceID>();
		wsis.add(wsi);
		return getPermissions(user, wsis).get(wsi);
	}
	
	@Override
	public Map<ResolvedWorkspaceID, Permission> getPermissions(
			final WorkspaceUser user, final Set<ResolvedWorkspaceID> rwsis)
			throws WorkspaceCommunicationException, 
			CorruptWorkspaceDBException {
		final Set<User> users = new HashSet<User>();
		if (user != null) {
			users.add(user);
		}
		users.add(allUsers);
		final Set<ResolvedMongoWSID> rm = new HashSet<ResolvedMongoWSID>();
		for (final ResolvedWorkspaceID r: rwsis) {
			rm.add(query.convertResolvedID(r));
		}
		final Map<ResolvedMongoWSID, Map<User, Permission>> perms = 
				query.queryPermissions(rm, users);
		final Map<ResolvedWorkspaceID, Permission> ret = 
				new HashMap<ResolvedWorkspaceID, Permission>();
		for (ResolvedMongoWSID r: perms.keySet()) {
			Permission p = Permission.NONE;
			if (perms.get(r).containsKey(allUsers)) {
				p = perms.get(r).get(allUsers); //if allUsers is in the DB it's always read
			}
			if (perms.get(r).containsKey(user) &&
					!perms.get(r).get(user).equals(Permission.NONE)) {
				p = perms.get(r).get(user);
			}
			ret.put(r, p);
		}
		return ret;
	}
	
	@Override
	public Map<User, Permission> getUserAndGlobalPermission(
			final WorkspaceUser user, final ResolvedWorkspaceID rwsi) throws
			WorkspaceCommunicationException, CorruptWorkspaceDBException {
		final Set<User> users = new HashSet<User>();
		users.add(allUsers);
		if (user != null) {
			users.add(user);
		}
		final Map<User, Permission> ret = query.queryPermissions(
				query.convertResolvedID(rwsi), users);
		if (!ret.containsKey(user)) {
			ret.put(user, Permission.NONE);
		}
		return ret;
	}

	@Override
	public Map<User, Permission> getAllPermissions(
			final ResolvedWorkspaceID rwsi) throws
			WorkspaceCommunicationException, CorruptWorkspaceDBException {
		return query.queryPermissions(query.convertResolvedID(rwsi));
	}

	private static final Set<String> FLDS_WS_ID_NAME_OWNER_MODDATE = 
			newHashSet(Fields.WS_ID, Fields.WS_NAME, Fields.WS_OWNER,
					Fields.WS_MODDATE);
	
	@Override
	public WorkspaceMetaData getWorkspaceMetadata(final WorkspaceUser user,
			final ResolvedWorkspaceID rwsi) throws 
			WorkspaceCommunicationException, CorruptWorkspaceDBException {
		final ResolvedMongoWSID m = query.convertResolvedID(rwsi);
		final Map<String, Object> ws = query.queryWorkspace(m,
				FLDS_WS_ID_NAME_OWNER_MODDATE);
		final Map<User, Permission> res = getUserAndGlobalPermission(user,
				m);
		return new MongoWSMeta((int) ws.get(Fields.WS_ID),
				(String) ws.get(Fields.WS_NAME),
				new WorkspaceUser((String) ws.get(Fields.WS_OWNER)),
				(Date) ws.get(Fields.WS_MODDATE), res.get(user),
				res.containsKey(allUsers));
	}
	
	private static class ObjID {
		public String name;
		public int id;
		
		public ObjID(String name, int id) {
			this.name = name;
			this.id = id;
		}

		@Override
		public String toString() {
			return "ObjID [name=" + name + ", id=" + id + "]";
		}
	}
	
	private static final Set<String> FLDS_PTR_ID_NAME =
			newHashSet(Fields.PTR_ID, Fields.PTR_NAME);
	
	private Map<WorkspaceObjectID, ObjID> getObjectIDs(
			final ResolvedMongoWSID workspaceID,
			final Set<WorkspaceObjectID> objects) throws
			WorkspaceCommunicationException {
		
		final Map<WorkspaceObjectID, ObjectIDResolvedWSNoVer> queryobjs = 
				new HashMap<WorkspaceObjectID, ObjectIDResolvedWSNoVer>();
		for (final WorkspaceObjectID o: objects) {
			queryobjs.put(o, new ObjectIDResolvedWSNoVer(workspaceID, o));
		}
		final Map<ObjectIDResolvedWSNoVer, Map<String, Object>> retobjs;
		try { 
			retobjs = query.queryObjects(
					new HashSet<ObjectIDResolvedWSNoVer>(queryobjs.values()),
					FLDS_PTR_ID_NAME, new HashSet<String>(), false);
		} catch (NoSuchObjectException nsoe) {
			throw new RuntimeException(
					"Threw a NoSuchObjectException when explicitly told not to");
		}
		
		final Map<WorkspaceObjectID, ObjID> goodIds =
				new HashMap<WorkspaceObjectID, ObjID>();
		for (final WorkspaceObjectID o: objects) {
			if (retobjs.containsKey(queryobjs.get(o))) {
				final Map<String, Object> pointer =
						retobjs.get(queryobjs.get(o));
				goodIds.put(o, new ObjID((String) pointer.get(Fields.PTR_NAME),
						(int) pointer.get(Fields.PTR_ID)));
			}
		}
		return goodIds;
	}
	
	private static final String M_SAVEINS_QRY = String.format("{%s: #, %s: #}",
			Fields.PTR_WS_ID, Fields.PTR_ID);
	private static final String M_SAVEINS_PROJ = String.format("{%s: 1, %s: 0}",
			Fields.PTR_VCNT, Fields.MONGO_ID);
	private static final String M_SAVEINS_WTH = String.format("{$inc: {%s: 1}}",
			Fields.PTR_VCNT);
	
	// save object in preexisting object container
	private ObjectMetaData saveObjectInstance(final WorkspaceUser user,
			final ResolvedMongoWSID wsid, final int objectid,
			final ObjectSavePackage pkg)
			throws WorkspaceCommunicationException {
		//TODO save datainstance/provenance
		final int ver;
		try {
			ver = (int) wsjongo.getCollection(COL_WORKSPACE_PTRS)
					.findAndModify(M_SAVEINS_QRY, wsid.getID(), objectid)
					.returnNew()
					.with(M_SAVEINS_WTH)
					.projection(M_SAVEINS_PROJ).as(DBObject.class)
					.get(Fields.PTR_VCNT);
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
		final DBObject query = new BasicDBObject();
		query.put(Fields.PTR_WS_ID, wsid.getID());
		query.put(Fields.PTR_ID, objectid);
		
		final DBObject pointer = new BasicDBObject();
		pointer.put(Fields.PTR_VER_VER, ver);
		pointer.put(Fields.PTR_VER_CREATEBY, user.getUser());
		pointer.put(Fields.PTR_VER_CHKSUM, pkg.td.getChksum());
		final List<Map<String, String>> meta = 
				new ArrayList<Map<String, String>>();
		if (pkg.wo.getUserMeta() != null) {
			for (String key: pkg.wo.getUserMeta().keySet()) {
				Map<String, String> m = new HashMap<String, String>();
				m.put(Fields.PTR_VER_META_KEY, key);
				m.put(Fields.PTR_VER_META_VALUE, pkg.wo.getUserMeta().get(key));
				meta.add(m);
			}
		}
		pointer.put(Fields.PTR_VER_META, meta);
		final Date created = new Date();
		pointer.put(Fields.PTR_VER_CREATEDATE, created);
		pointer.put(Fields.PTR_VER_REF, new ArrayList<Object>()); //TODO this might be a really bad idea
		pointer.put(Fields.PTR_VER_PROV, null); //TODO add objectID
		pointer.put(Fields.PTR_VER_TYPE, pkg.td.getType().getTypeString());
		pointer.put(Fields.PTR_VER_SIZE, pkg.td.getSize());
		pointer.put(Fields.PTR_VER_RVRT, null);
		final DBObject versions = new BasicDBObject();
		versions.put(Fields.PTR_VERS, pointer);
		final DBObject update = new BasicDBObject();
		update.put("$push", versions);
		final DBObject deleted = new BasicDBObject();
		deleted.put(Fields.PTR_DEL, false);
		deleted.put(Fields.PTR_MODDATE, created);
		update.put("$set", deleted);
		
		try {
			wsmongo.getCollection(COL_WORKSPACE_PTRS).update(query, update);
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
		return new MongoObjectMeta(objectid, pkg.name,
				pkg.td.getType().getTypeString(), created, ver, user, wsid,
				pkg.td.getChksum(), pkg.td.getSize());
	}
	
	//TODO make all projections not include _id unless specified
	
	private static final String M_UNIQ_NAME_QRY = String.format(
			"{%s: #, %s: {$regex: '^#'}}", Fields.PTR_WS_ID, Fields.PTR_NAME);
	private static final String M_UNIQ_NAME_PROJ = String.format(
			"{%s: 1, %s: 0}", Fields.PTR_NAME, Fields.MONGO_ID);
	
	private String generateUniqueNameForObject(final ResolvedWorkspaceID wsid,
			final int objectid) throws WorkspaceCommunicationException {
		@SuppressWarnings("rawtypes")
		Iterable<Map> ids;
		try {
			ids = wsjongo.getCollection(COL_WORKSPACE_PTRS)
					.find(M_UNIQ_NAME_QRY, wsid.getID(), objectid)
					.projection(M_UNIQ_NAME_PROJ).as(Map.class);
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
		boolean exact = false;
		final Set<Integer> suffixes = new HashSet<Integer>();
		for (@SuppressWarnings("rawtypes") Map m: ids) {
			
			final String[] id = ((String) m.get(Fields.PTR_NAME)).split("-");
			if (id.length == 2) {
				try {
					suffixes.add(Integer.parseInt(id[1]));
				} catch (NumberFormatException e) {
					// do nothing
				}
			} else if (id.length == 1) {
				try {
					exact = exact || objectid == Integer.parseInt(id[0]);
				} catch (NumberFormatException e) {
					// do nothing
				}
			}
		}
		if (!exact) {
			return "" + objectid;
		}
		int counter = 1;
		while (suffixes.contains(counter)) {
			counter++;
		}
		return objectid + "-" + counter;
	}
	
	//save brand new object - create container
	//objectid *must not exist* in the workspace otherwise this method will recurse indefinitely
	//the workspace must exist
	private ObjectMetaData saveObjectWithNewPointer(final WorkspaceUser user,
			final ResolvedMongoWSID wsid, final int objectid, final String name,
			final ObjectSavePackage pkg) throws WorkspaceCommunicationException {
		String newName = name;
		if (name == null) {
			newName = generateUniqueNameForObject(wsid, objectid);
			pkg.name = newName;
		}
		final DBObject dbo = new BasicDBObject();
		dbo.put(Fields.PTR_WS_ID, wsid.getID());
		dbo.put(Fields.PTR_ID, objectid);
		dbo.put(Fields.PTR_VCNT, 0);
		dbo.put(Fields.PTR_NAME, newName);
		//deleted handled in saveObjectInstance()
		dbo.put(Fields.PTR_HIDE, false); //TODO hidden, also set hidden when not creating pointer from scratch
		dbo.put(Fields.PTR_VERS, new ArrayList<Object>());
		try {
			//maybe could speed things up with batch inserts but dealing with
			//errors would really suck
			//do this later if it becomes a bottleneck
			wsmongo.getCollection(COL_WORKSPACE_PTRS).insert(dbo);
		} catch (MongoException.DuplicateKey dk) {
			//ok, someone must've just this second added this name to an object
			//asshole
			//this should be a rare event
			//TODO is this a name or id clash? if the latter, something is broken
			if (name == null) {
				//not much chance of this happening again, let's just recurse
				return saveObjectWithNewPointer(user, wsid, objectid, name, pkg);
			}
			final WorkspaceObjectID o = pkg.wo.getObjectIdentifier();
			final Map<WorkspaceObjectID, ObjID> objID = getObjectIDs(wsid,
					new HashSet<WorkspaceObjectID>(Arrays.asList(o)));
			if (objID.isEmpty()) {
				//oh ffs, name deleted again, recurse
				return saveObjectWithNewPointer(user, wsid, objectid, name, pkg);
			}
			return saveObjectInstance(user, wsid, objID.get(o).id, pkg);
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
		return saveObjectInstance(user, wsid, objectid, pkg);
	}
	
	//TODO can get rid of this?
	private static class ObjectSavePackage {
		
		public ResolvedSaveObject wo;
		public String name;
		public TypeData td;
		
		@Override
		public String toString() {
			return "ObjectSavePackage [wo=" + wo + ", name=" + name + ", td="
					+ td + "]";
		}
	}
	
	private static final ObjectMapper MAPPER_DEFAULT = new ObjectMapper();
	private static final ObjectMapper MAPPER_SORTED = new ObjectMapper();
	static {
		MAPPER_SORTED.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);
	}
	
	private static String getObjectErrorId(final WorkspaceObjectID oi,
			final int objcount) {
		String objErrId = "#" + objcount;
		objErrId += oi == null ? "" : ", " + oi.getIdentifierString();
		return objErrId;
	}
	
	//at this point the objects are expected to be validated and references rewritten
	private List<ObjectSavePackage> saveObjectsBuildPackages(
			final ResolvedMongoWSID rwsi,
			final List<ResolvedSaveObject> objects) {
		//this method must maintain the order of the objects
		int objnum = 1;
		final List<ObjectSavePackage> ret = new LinkedList<ObjectSavePackage>();
		for (ResolvedSaveObject o: objects) {
			final ObjectSavePackage pkg = new ObjectSavePackage();
			pkg.wo = o;
			final String json;
			try {
				final Object obj = MAPPER_SORTED.treeToValue(o.getData(),
						Object.class);
				json = MAPPER_SORTED.writeValueAsString(obj);
			} catch (JsonProcessingException jpe) {
				throw new IllegalArgumentException(
						"Couldn't serialize data from object " +
						getObjectErrorId(o.getObjectIdentifier(), objnum));
			}
			//TODO get subdata (later)?
			//TODO check subdata size
			//TODO change subdata disallowed chars - html encode (%)
			//TODO when safe, add references to references collection
			//could save time by making type->data->TypeData map and reusing
			//already calced TDs, but hardly seems worth it - unlikely event
			pkg.td = new TypeData(json, o.getType(), rwsi, null); //TODO add subdata
			ret.add(pkg);
			objnum++;
		}
		return ret;
	}
	
	private static final String M_SAVE_QRY = String.format("{%s: #}",
					Fields.WS_ID);
	private static final String M_SAVE_WTH = String.format("{$inc: {%s: #}}",
					Fields.WS_NUMPTR);
	private static final String M_SAVE_PROJ = String.format("{%s: 1, %s: 0}",
			Fields.WS_NUMPTR, Fields.MONGO_ID);
			
	//at this point the objects are expected to be validated and references rewritten
	@Override
	public List<ObjectMetaData> saveObjects(final WorkspaceUser user, 
			final ResolvedWorkspaceID rwsi,
			final List<ResolvedSaveObject> objects) throws
			NoSuchWorkspaceException, WorkspaceCommunicationException,
			NoSuchObjectException {
		//TODO break this up
		//this method must maintain the order of the objects
		final List<ObjectMetaData> ret = new ArrayList<ObjectMetaData>();
		
		final ResolvedMongoWSID wsidmongo = query.convertResolvedID(rwsi);
		final List<ObjectSavePackage> packages = saveObjectsBuildPackages(
				wsidmongo, objects);
		final Map<WorkspaceObjectID, List<ObjectSavePackage>> idToPkg =
				new HashMap<WorkspaceObjectID, List<ObjectSavePackage>>();
		int newobjects = 0;
		for (final ObjectSavePackage p: packages) {
			final WorkspaceObjectID o = p.wo.getObjectIdentifier();
			if (o != null) {
//				names.add(p.wo.getObjectIdentifier());
				if (idToPkg.get(o) == null) {
					idToPkg.put(o, new ArrayList<ObjectSavePackage>());
				}
				idToPkg.get(o).add(p);
			} else {
				newobjects++;
			}
		}
		final Map<WorkspaceObjectID, ObjID> objIDs = getObjectIDs(wsidmongo,
				idToPkg.keySet());
		for (WorkspaceObjectID o: idToPkg.keySet()) {
			if (!objIDs.containsKey(o)) {
				if (o.getId() != null) {
					throw new NoSuchObjectException(
							"There is no object with id " + o.getId());
				} else {
					for (ObjectSavePackage pkg: idToPkg.get(o)) {
						pkg.name = o.getName();
					}
					newobjects++;
				}
			} else {
				for (ObjectSavePackage pkg: idToPkg.get(o)) {
					pkg.name = objIDs.get(o).name;
				}
			}
		}
		//at this point everything should be ready to save, only comm errors
		//can stop us now, the world is doomed
		saveData(wsidmongo, packages);
		final int lastid;
			try {
				lastid = (int) wsjongo.getCollection(COL_WORKSPACES)
						.findAndModify(M_SAVE_QRY, wsidmongo.getID())
						.returnNew().with(M_SAVE_WTH, newobjects)
						.projection(M_SAVE_PROJ)
						.as(DBObject.class).get(Fields.WS_NUMPTR);
			} catch (MongoException me) {
				throw new WorkspaceCommunicationException(
						"There was a problem communicating with the database", me);
			}
		//TODO batch updates when everything known to be ok
		int newid = lastid - newobjects + 1;
		//todo get counts and numbers
		final Map<String, Integer> seenNames = new HashMap<String, Integer>();
		for (final ObjectSavePackage p: packages) {
			final WorkspaceObjectID oi = p.wo.getObjectIdentifier();
			if (oi == null) { //no name given, need to generate one
				ret.add(saveObjectWithNewPointer(user, wsidmongo, newid++, null, p));
			} else if (oi.getId() != null) { //confirmed ok id
				ret.add(saveObjectInstance(user, wsidmongo, oi.getId(), p));
			} else if (objIDs.get(oi) != null) {//given name translated to id
				ret.add(saveObjectInstance(user, wsidmongo, objIDs.get(oi).id, p));
			} else if (seenNames.containsKey(oi.getName())) {
				//we've already generated an id for this name
				ret.add(saveObjectInstance(user, wsidmongo, seenNames.get(oi.getName()), p));
			} else {//new name, need to generate new id
				final ObjectMetaData m = saveObjectWithNewPointer(user, wsidmongo,
						newid++, oi.getName(), p);
				ret.add(m);
				seenNames.put(oi.getName(), m.getObjectId());
			}
		}
		return ret;
	}
	
	private static final String M_SVDTA_QRY = String.format("{%s: #}",
			Fields.TYPE_CHKSUM);
	private static final String M_SVDTA_WTH = String.format(
			"{$addToSet: {%s: #}}", Fields.TYPE_WS);
	
	//TODO break this up
	private void saveData(final ResolvedMongoWSID workspaceid,
			final List<ObjectSavePackage> data) throws
			WorkspaceCommunicationException {
		final Map<AbsoluteTypeDefId, List<ObjectSavePackage>> pkgByType =
				new HashMap<AbsoluteTypeDefId, List<ObjectSavePackage>>();
		for (final ObjectSavePackage p: data) {
			if (pkgByType.get(p.td.getType()) == null) {
				pkgByType.put(p.td.getType(), new ArrayList<ObjectSavePackage>());
			}
			pkgByType.get(p.td.getType()).add(p);
		}
		for (final AbsoluteTypeDefId type: pkgByType.keySet()) {
			ensureTypeIndexes(type); //TODO do this on adding type and on startup
			final String col = getTypeCollection(type);
			final Map<String, TypeData> chksum = new HashMap<String, TypeData>();
			for (ObjectSavePackage p: pkgByType.get(type)) {
				chksum.put(p.td.getChksum(), p.td);
			}
			final DBObject query = new BasicDBObject();
			final DBObject inchk = new BasicDBObject();
			inchk.put("$in", new ArrayList<String>(chksum.keySet()));
			query.put(Fields.TYPE_CHKSUM, inchk);
			final DBObject proj = new BasicDBObject();
			proj.put(Fields.TYPE_CHKSUM, 1);
			proj.put(Fields.MONGO_ID, 0);
			DBCursor res;
			try {
				res = wsmongo.getCollection(col).find(query, proj);
			} catch (MongoException me) {
				throw new WorkspaceCommunicationException(
						"There was a problem communicating with the database", me);
			}
			final Set<String> existChksum = new HashSet<String>();
			for (DBObject dbo: res) {
				existChksum.add((String)dbo.get(Fields.TYPE_CHKSUM));
			}
			
			//TODO what happens if a piece of data is deleted after pulling the existing chksums? pull workspaces field, if empty do an upsert just in case
			final List<TypeData> newdata = new ArrayList<TypeData>();
			for (String md5: chksum.keySet()) {
				if (existChksum.contains(md5)) {
					try { //TODO need a test for this once admin stuff is ready
						wsjongo.getCollection(col)
								.update(M_SVDTA_QRY, md5)
								.with(M_SVDTA_WTH, workspaceid.getID());
					} catch (MongoException me) {
						throw new WorkspaceCommunicationException(
								"There was a problem communicating with the database",
								me);
					}
					continue;
				}
				newdata.add(chksum.get(md5));
				try {
					//this is kind of stupid, but no matter how you slice it you have
					//to calc md5s before you save the data
					blob.saveBlob(new MD5(md5), chksum.get(md5).getData());
				} catch (BlobStoreCommunicationException e) {
					throw new WorkspaceCommunicationException(
							e.getLocalizedMessage(), e);
				} catch (BlobStoreAuthorizationException e) {
					throw new WorkspaceCommunicationException(
							"Authorization error communicating with the backend storage system",
							e);
				}
			}
			try {
				wsjongo.getCollection(col).insert((Object[]) newdata.toArray(
						new TypeData[newdata.size()]));
			} catch (MongoException.DuplicateKey dk) {
				//dammit, someone just inserted this data
				//we'll have to go one by one doing upserts
				for (TypeData td: newdata) {
					final DBObject ckquery = new BasicDBObject();
					query.put(Fields.TYPE_CHKSUM, td.getChksum());
					wsmongo.getCollection(col).update(ckquery, td.getSafeUpdate(), true, false);
				}
			} catch (MongoException me) {
				throw new WorkspaceCommunicationException(
						"There was a problem communicating with the database", me);
			}
		}
		//TODO save provenance as batch and add prov id to pkgs
	}
	
	private String getTypeCollection(final AbsoluteTypeDefId type) {
		return "type-" + type.getType().getTypeString() + "-" +
				type.getMajorVersion();
	}
	
	public Map<ObjectIDResolvedWS, WorkspaceObjectData> getObjects(
			final Set<ObjectIDResolvedWS> objectIDs) throws
			NoSuchObjectException, WorkspaceCommunicationException,
			CorruptWorkspaceDBException {
		final Map<ObjectIDResolvedWSNoVer, Map<String, Object>> pointerData =
				getPointerData(objectIDs);
		final Map<ObjectIDResolvedWS, WorkspaceObjectData> ret =
				new HashMap<ObjectIDResolvedWS, WorkspaceObjectData>();
		final Map<String, Object> chksumToData = new HashMap<String, Object>();
		for (ObjectIDResolvedWS o: objectIDs) {
			final MongoObjectUserMeta meta = generateUserMeta(
					pointerData.get(o.withoutVersion()),
					o.getVersion(), 
					Integer.toString(o.getWorkspaceIdentifier().getID()),
					o.getIdentifierString());
			if (chksumToData.containsKey(meta.getCheckSum())) {
				ret.put(o, new WorkspaceObjectData(
						chksumToData.get(meta.getCheckSum()), meta));
			} else {
				final String data;
				try {
					data = blob.getBlob(new MD5(meta.getCheckSum()));
				} catch (BlobStoreCommunicationException e) {
					throw new WorkspaceCommunicationException(
							e.getLocalizedMessage(), e);
				} catch (BlobStoreAuthorizationException e) {
					throw new WorkspaceCommunicationException(
							"Authorization error communicating with the backend storage system",
							e);
				} catch (NoSuchBlobException e) {
					throw new CorruptWorkspaceDBException(String.format(
							"No data present for valid pointer %s.%s.%s",
							meta.getWorkspaceId(), meta.getObjectId(),
							meta.getVersion()), e);
				}
				final Object object;
				try {
					object = MAPPER_DEFAULT.readValue(data, Object.class);
				} catch (IOException e) {
					throw new RuntimeException(String.format(
							"Unable to deserialize object %s",
							meta.getCheckSum()), e); 
				}
				chksumToData.put(meta.getCheckSum(), object);
				ret.put(o, new WorkspaceObjectData(object, meta));
			}
		}
		return ret;
	}
	
	private static final Set<String> FLDS_PTR_META =
			newHashSet(Fields.PTR_ID, Fields.PTR_NAME, Fields.PTR_WS_ID,
			Fields.PTR_VCNT, Fields.PTR_DEL);
	private static final Set<String> FLDS_PTR_META_VER = newHashSet(
			Fields.PTR_VER_VER, Fields.PTR_VER_META, Fields.PTR_VER_TYPE,
			Fields.PTR_VER_CREATEDATE, Fields.PTR_VER_CREATEBY,
			Fields.PTR_VER_CHKSUM, Fields.PTR_VER_SIZE);
	
	private static final String FKFLD_MAXVER = "maxver";

	private Map<ObjectIDResolvedWSNoVer, Map<String, Object>> getPointerData(
			final Set<ObjectIDResolvedWS> objectIDs) throws
			NoSuchObjectException, WorkspaceCommunicationException {
		final Set<ObjectIDResolvedWSNoVer> noVer =
				new HashSet<ObjectIDResolvedWSNoVer>();
		for (final ObjectIDResolvedWS o: objectIDs) {
			noVer.add(o.withoutVersion());
		}
		
		final Map<ObjectIDResolvedWSNoVer, Map<String, Object>> qres =
				query.queryObjects(noVer, FLDS_PTR_META, FLDS_PTR_META_VER);

		//preprocess data structure for faster access if multiple versions
		//of same object required
		for (ObjectIDResolvedWSNoVer o: qres.keySet()) {
			final Map<String, Object> pointer = qres.get(o);
			if ((boolean) pointer.get(Fields.PTR_DEL)) {
				throw new NoSuchObjectException(String.format(
						"Object %s in workspace %s has been deleted",
						o.getIdentifierString(),
						o.getWorkspaceIdentifier().getID()));
			}
			@SuppressWarnings("unchecked")
			final List<Map<String, Object>> listver =
					(List<Map<String, Object>>) pointer.get(Fields.PTR_VERS);
			final Map<Integer, Map<String, Object>> versions =
					new HashMap<Integer, Map<String,Object>>();
			int maxver = -1;
			for (final Map<String, Object> m: listver) {
				final int ver = (int) m.get(Fields.PTR_VER_VER);
				if (ver > maxver) {
					maxver = ver;
				}
				versions.put(ver, m);
			}
			pointer.put(FKFLD_MAXVER, maxver);
			pointer.put(Fields.PTR_VERS, versions);
		}
		return qres;
	}
	
	private MongoObjectUserMeta generateUserMeta(
			final Map<String, Object> pointer, final Integer version,
			final String workspaceIdentifier, final String objectIdentifier)
			throws NoSuchObjectException {
		final int maxver = (int) pointer.get(FKFLD_MAXVER);
		final int ver;
		if (version == null) {
			if (maxver < 1) {
				throw new NoSuchObjectException(String.format(
						"No object with identifier '%s' exists in workspace %s",
						objectIdentifier, workspaceIdentifier));
			}
			ver = maxver;
		} else {
			ver = version; //bad version error will be caught below
		}
		@SuppressWarnings("unchecked")
		final Map<String, Object> verpoint = 
				((Map<Integer, Map<String, Object>>)
						pointer.get(Fields.PTR_VERS)).get(ver);
		if (verpoint == null) { // it's been deleted //TODO test when garbage collection is implemented
			throw new NoSuchObjectException(String.format(
					"No object with identifier '%s' and version %s exists in workspace %s",
					objectIdentifier, ver, workspaceIdentifier));
		}
		@SuppressWarnings("unchecked")
		final List<Map<String, String>> meta =
				(List<Map<String, String>>) verpoint.get(Fields.PTR_VER_META);
		return new MongoObjectUserMeta(
				(int) pointer.get(Fields.PTR_ID),
				(String) pointer.get(Fields.PTR_NAME),
				(String) verpoint.get(Fields.PTR_VER_TYPE),
				(Date) verpoint.get(Fields.PTR_VER_CREATEDATE), ver,
				new WorkspaceUser((String) verpoint.get(Fields.PTR_VER_CREATEBY)),
				new ResolvedMongoWSID((int) pointer.get(Fields.PTR_WS_ID)),
				(String) verpoint.get(Fields.PTR_VER_CHKSUM),
				(int) verpoint.get(Fields.PTR_VER_SIZE),
				metaMongoArrayToHash(meta));
	}
	
	//TODO provide the workspace name for error purposes
	@Override
	public Map<ObjectIDResolvedWS, ObjectUserMetaData> getObjectMeta(
			final Set<ObjectIDResolvedWS> objectIDs) throws
			NoSuchObjectException, WorkspaceCommunicationException {
		final Map<ObjectIDResolvedWSNoVer, Map<String, Object>> pointerData =
				getPointerData(objectIDs);
		final Map<ObjectIDResolvedWS, ObjectUserMetaData> ret =
				new HashMap<ObjectIDResolvedWS, ObjectUserMetaData>();
		for (ObjectIDResolvedWS o: objectIDs) {
			ret.put(o, generateUserMeta(pointerData.get(o.withoutVersion()),
					o.getVersion(), 
					Integer.toString(o.getWorkspaceIdentifier().getID()),
					o.getIdentifierString()));
		}
		return ret;
	}
	
	private Map<String, String> metaMongoArrayToHash(
			final List<Map<String, String>> meta) {
		final Map<String, String> ret = new HashMap<String, String>();
		for (final Map<String, String> m: meta) {
			ret.put(m.get(Fields.PTR_VER_META_KEY),
					m.get(Fields.PTR_VER_META_VALUE));
		}
		return ret;
	}
	
	private Map<ObjectIDResolvedWSNoVer, Integer> resolveObjectIDs(
			final Set<ObjectIDResolvedWSNoVer> objectIDs)
			throws NoSuchObjectException, WorkspaceCommunicationException {
		final Map<ObjectIDResolvedWSNoVer, Map<String, Object>> ids = 
				query.queryObjects(objectIDs, FLDS_PTR_ID, null);
		final Map<ObjectIDResolvedWSNoVer, Integer> ret =
				new HashMap<ObjectIDResolvedWSNoVer, Integer>();
		for (final ObjectIDResolvedWSNoVer o: objectIDs) {
			ret.put(o, (Integer) ids.get(o).get(Fields.PTR_ID));
		}
		return ret;
	}
	
	private Map<ResolvedMongoWSID, List<Integer>> getObjectIDsByWS(
			final Set<ObjectIDResolvedWSNoVer> objectIDs)
			throws NoSuchObjectException, WorkspaceCommunicationException {
		final Map<ObjectIDResolvedWSNoVer, Integer> ids =
				resolveObjectIDs(objectIDs);
		final Map<ResolvedMongoWSID, List<Integer>> wsToIDs = 
				new HashMap<ResolvedMongoWSID, List<Integer>>();
		for (final ObjectIDResolvedWSNoVer o: objectIDs) {
			final ResolvedMongoWSID ws = query.convertResolvedID(
					o.getWorkspaceIdentifier());
			if (!wsToIDs.containsKey(ws)) {
				wsToIDs.put(ws, new ArrayList<Integer>());
			}
			wsToIDs.get(ws).add(ids.get(o));
		}
		return wsToIDs;
	}

	@Override
	public void setObjectsDeleted(final Set<ObjectIDResolvedWSNoVer> objectIDs,
			final boolean delete)
			throws NoSuchObjectException, WorkspaceCommunicationException {
		final Map<ResolvedMongoWSID, List<Integer>> toModify = 
				getObjectIDsByWS(objectIDs);
		//Do this by workspace since per mongo docs nested $ors are crappy
		for (final ResolvedMongoWSID ws: toModify.keySet()) {
			setObjectsDeleted(ws, toModify.get(ws), delete);
		}
	}
	
	private static final String M_DELOBJ_WTH = String.format(
			"{$set: {%s: #, %s: #}}", Fields.PTR_DEL, Fields.PTR_MODDATE);
	
	private void setObjectsDeleted(final ResolvedMongoWSID ws,
			final List<Integer> objectIDs, final boolean delete)
			throws WorkspaceCommunicationException {
		final String query;
		if (objectIDs.isEmpty()) {
			query = String.format(
					"{%s: %s, %s: %s}", Fields.PTR_WS_ID, ws.getID(),
					Fields.PTR_DEL, !delete);
		} else {
			query = String.format(
					"{%s: %s, %s: {$in: [%s]}, %s: %s}",
					Fields.PTR_WS_ID, ws.getID(), Fields.PTR_ID,
					StringUtils.join(objectIDs, ", "), Fields.PTR_DEL, !delete);
		}
		try {
			wsjongo.getCollection(COL_WORKSPACE_PTRS).update(query).multi()
					.with(M_DELOBJ_WTH, delete, new Date());
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
	}
	
	private static final String M_DELWS_UPD = String.format("{%s: #}",
						Fields.WS_ID);
	private static final String M_DELWS_WTH = String.format(
			"{$set: {%s: #, %s: #}}", Fields.WS_DEL, Fields.WS_MODDATE);
	
	public void setWorkspaceDeleted(final ResolvedWorkspaceID rwsi,
			final boolean delete) throws WorkspaceCommunicationException {
		//there's a possibility of a race condition here if a workspace is
		//deleted and undeleted or vice versa in a very short amount of time,
		//but that seems so unlikely it's not worth the code
		final ResolvedMongoWSID mrwsi = query.convertResolvedID(rwsi);
		try {
			wsjongo.getCollection(COL_WORKSPACES).update(
							M_DELWS_UPD, mrwsi.getID())
					.with(M_DELWS_WTH, delete, new Date());
		} catch (MongoException me) {
			throw new WorkspaceCommunicationException(
					"There was a problem communicating with the database", me);
		}
		setObjectsDeleted(mrwsi, new ArrayList<Integer>(), delete);
	}
	
	public static class TestMongoInternals {
		
		//screwy tests for methods that can't be tested in a black box manner
	
		private static MongoDatabase testdb;
		
		@BeforeClass
		public static void setUpClass() throws Exception {
			WorkspaceTestCommon.destroyAndSetupDB(1, "gridFS", "foo");
			String host = WorkspaceTestCommon.getHost();
			String db1 = WorkspaceTestCommon.getDB1();
			String mUser = WorkspaceTestCommon.getMongoUser();
			String mPwd = WorkspaceTestCommon.getMongoPwd();
			if (mUser == null || mUser == "") {
				testdb = new MongoDatabase(host, db1, "foo");
			} else {
				testdb = new MongoDatabase(host, db1, "foo", mUser, mPwd);
			}
		}
		
		@Test
		public void createPointer() throws Exception {
			testdb.createWorkspace(new WorkspaceUser("u"), "ws", false, null);
			Map<String, Object> data = new HashMap<String, Object>();
			Map<String, String> meta = new HashMap<String, String>();
			Map<String, Object> moredata = new HashMap<String, Object>();
			moredata.put("foo", "bar");
			data.put("fubar", moredata);
			meta.put("metastuff", "meta");
			Provenance p = new Provenance("kbasetest2");
			TypeDefId t = new TypeDefId(new TypeDefName("SomeModule", "AType"), 0, 1);
			AbsoluteTypeDefId at = new AbsoluteTypeDefId(new TypeDefName("SomeModule", "AType"), 0, 1);
			WorkspaceSaveObject wo = new WorkspaceSaveObject(
					new WorkspaceObjectID("testobj"),
					MAPPER_DEFAULT.valueToTree(data), t, meta, p, false);
			List<ResolvedSaveObject> wco = new ArrayList<ResolvedSaveObject>();
			wco.add(wo.resolve(at, wo.getData()));
			ObjectSavePackage pkg = new ObjectSavePackage();
			pkg.wo = wo.resolve(at, wo.getData());
			ResolvedMongoWSID rwsi = new ResolvedMongoWSID(1);
			pkg.td = new TypeData(MAPPER_DEFAULT.writeValueAsString(data), at, rwsi , data);
			testdb.saveObjects(new WorkspaceUser("u"), rwsi, wco);
			ObjectMetaData md = testdb.saveObjectWithNewPointer(new WorkspaceUser("u"), rwsi, 3, "testobj", pkg);
			assertThat("objectid is revised to existing object", md.getObjectId(), is(1));
		}
	}
}
