.. _typedobjects:

Workspace Typed Objects
=======================

The Workspace Service (WSS) provides storage, sharing, versioning, validation
and provenance tracking of typed object (TO) data.  This document describes
basic information for developers who need to define and register TOs for use
with the WSS.

Typed Object Basics
-------------------

TOs in the WSS are hierarchical data objects that conform to type
definitions specified in the KBase Interface Description Language (KIDL). Just
as KIDL is used to specify the structure of data exchanged between KBase
clients and servers (generated by the Type Compiler), KIDL is used to define
the structure of data stored in the WSS.

Any structures defined in a KIDL formatted file
(e.g. ``typedef structure { … } StructureName``;) can be registered with the
WSS (see :ref:`typedobjectregandver`).  Instances of these objects can then be
saved to the WSS by any user. The WSS does not support storage of primitive or
basic container types directly (ie string, int, float, list, mapping).

KIDL defined Modules provides namespacing for typed objects. Thus, the module
name and type name is required to uniquely identify a type in the WSS,
generally in the format ``ModuleName.TypeName``.

.. _typedobjectregandver:

Typed Object Registration & Versioning
--------------------------------------

TO definitions must be registered with the WSS before instances of the TOs can
be saved.  The basic process for registering a TO is:

* Developer requests ownership of a module name via the Workspace API or CLI

  * see script ``ws-typespec-register --request``, or API method
    ``request_module_ownership(...)``

* WSS admin approves the request
* Developer uploads (i.e. registers) a type specification file (typespec) in
  KIDL format where the module name is identical to the just approved module
  name in the WSS and indicates the names of the TOs which the developer
  wants the WSS to support
  
  * see script ``ws-typespec-register --typespec``, or API method
    ``register_typespec(...)``

* Developer releases the module, which releases the latest version of all
  TO definitions in the module

  * see script ``ws-typespec-register --release`` or API method
    ``release_module(...)``
    
See :ref:`scripts` for more information on the ``ws-typespec-register`` script.

See :ref:`releasetypespecexample` for step-by-step instructions via the
command-line.

TO definitions marked for WSS usage are versioned with a major
and minor version.  Every time a new typespec is uploaded and registered, the
TO definitions defined in the module automatically receive a new
version number if changed. Minor versions are incremented if the change is
backwards compatible (i.e. addition of a new optional field). Major versions
are incremented if the change is not backwards compatible.

All versions of all registered TO definitions are available to
WSS users, but to save an object instance of an old version, or an
unreleased version, the exact version number must be provided by the user.
If a WSS user saves an object instance without providing version numbers
for the type, the latest released version of the TO definition is
assumed.  The process of releasing a module therefore indicates that the latest
version of all typed object definitions in the module are ready for public use,
but does not limit user’s or developer’s ability to work with old or
pre-released versions of TOs.

Before the first release of a module, repeated uploads of a module result in
version numbers of TO definitions of 0.x and are assumed to be
backwards incompatible.  On first release of a module, all version numbers of
TO definitions are updated to 1.0.

Users and developers can use the ``ws-typespec-list`` script or the API to list
registered modules, type definitions, and versions of type definitions, and to
retrieve the actual KIDL or JSON schema encoding of the typed object
definition.  End users will only be able to view the versions of TOs
that are released. Owners of a module can list all versions of TOs
in modules that they own.


Typed Object Validation
-----------------------

Instances of TOs can be validated against type definitions registered with the
WSS. Instances of TOs must pass this validation process to be stored in the
WSS, thereby guaranteeing that WSS data is structurally valid.

The WSS by validates the TO instance against a
`JSON Schema V4 <http://json-schema.org/documentation.html>`_ encoding of the
TO definition.  The JSON Schema encoding can be generated by the KBase Type
Compiler (currently in branch ``dev-prototypes``). In addition to matching the
structure and type of data, additional constraints can be placed on TO
validation through the use of Annotations (see :ref:`typedobjectannotations`).

.. todo::
   Update location of type compiler code - in kb-sdk? Check that paragraph
   describing generation of JSON encodings is still valid.

To generate JSON encodings of your TOs for review, checkout the
``dev-prototypes`` branch of the typecompiler and compile your typespec file
with the ``--jsonschema`` option of the ``compile_typespec`` command.  The JSON
Schema encoding of each object definition is generated in the output location
in a directory called jsonschema.  The JSON Schema encoding is also available
for all registered TO definitions via the WSS API or the ``ws-typespec-list``
command.

All TO instances pulled from the WSS are guaranteed to be valid instances of a
TO definition as registered with the WSS.  Therefore it is recommended that
KBase services which require rigorous validation of complex data operate on
data stored in the WSS (as opposed to passing the object by value and writing
the validation code yourself).  Note that full validation is not built into
generated KBase client/server code, so it is not safe to assume that input data
received directly from a type compiler generated client conforms to the
specified type definitions in your API.  

Additional technical details: The TO validation code is written in Java and is
available in the
`workspace_deluxe KBase repo <https://github.com/kbase/workspace_deluxe>`_.

.. _typedobjectannotations:

Typed Object Annotations
------------------------

Annotations provide an infrastructure for attaching structured meta data to
type definitions (and eventually to functions and modules). Such meta data is
useful for specifying additional constraints on data types, interpreting data
types within a particular context, and declaring structured information that
can later be automatically indexed or searched, such as authorship of a
function implementation.

Annotations are declared in the comment immediately preceding the definition of
the TO. Thus, all annotations are always attached and viewable within the API
documentation.  Each annotation must be specified on its own line in the
following format::

    @[ANNOTATION] [INFO]

where ``[ANNOTATION]`` is the name of the annotation and ``[INFO]`` is any
additional information, if any, required of the annotation. To provide a simple
example which associates authorship information to a TO using the ``@author``
annotation::

    /*
      Data type for my experimental data.
      @author John Scientist
    */
    typedef structure {
        string name;
        list <int> results;
    } MyExperimentData;


Currently Supported Type Definition Annotations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Optional Annotation
"""""""""""""""""""
Mark a specific field of a structure as an optional field.  The optional
annotation can only be declared where a structure is first defined.  On
validation of TO instances by the WSS, missing optional fields are permitted.
If an optional field is present, however, the value of the field will be
validated normally.  Optional fields are defined as::

    @optional [FIELD_NAME_1] [FIELD_NAME_2] ... 

For example, the following annotation will declare that two fields of the
structure are optional.::

    /*
      @optional alias functional_assignments
    */
    typedef structure {
        string name;
        string alias;
        string sequence;
        list <string> functional_assignments;
    } Feature;

.. _idannotations:

ID Annotations
""""""""""""""
Mark a string as an ID that references another object or entity. ID annotations
can only be associated to type definitions which resolve to a string. ID
annotations are declared in the general form::

    @id [ID_TYPE] [PARAMETERS]

where ``[ID_TYPE]`` specifies the type of ID and is required, and
``[PARAMETERS]`` provides additional information or constraints.
``[PARAMETERS]`` are always optional.

ID annotations are inherited when declaring a new ``typedef`` of a string that
was already marked as an ID.  If a new ID Annotation is declared in a
``typedef``, it overrides any previous ID declaration.

Note that although ``@id`` annotations may be specified as any ``ID_TYPE`` and
associated to any ``typedef``, applications that consume type specifications
(primarily the workspace at the time of writing) may only recognize specific
``@id`` ``ID_TYPE`` / ``typedef`` combinations.

The ID types currently supported are described below.

**Workspace ID**
::

    @id ws [TYPEDEF_NAME] ... 

The ID must reference a TO instance stored in the WSS. There are multiple valid
ways to specify a workspace object, and all are acceptable. Optionally, one or
more type definition names can be specified indicating that the ID must point
to a TO instance that is one of the specified types. The typedef with which the
``@id`` annotation is associated must be a string.

Example::

    /*
       A reference to a genome.
       @id ws KB.MicrobialGenome KB.PlantGenome
    */
    typedef string genome_id;

**KBase ID**
::

    @id kb
    
The ID must reference a KBase ID which is typically registered in the 
`ID service <https://github.com/kbase/idserver>`_ in a format such as
“kb|type.XXX”.  No type checking on this field is performed, but the annotation
may be used in the future so that users can automatically extract KBase IDs
from typed objects.

**Handle ID**
::

    @id handle

The ID must reference a Handle ID from the
`Handle Service <https://github.com/kbase/handle_service>`_. This is typically
in the format KBH_XXX. When saving an object containing one or more handles to
the WSS, the WSS checks that the handles are readable by the user before
completing the save. Furthermore, the handle data is shared as the workspace
object is shared. See :ref:`shockintegration` for more details.

**External ID**
::

    @id external [SOURCE] ...
 
The ID must reference an entity in an external (i.e. outside of KBase) data
store.  The IDs are not verified or validated, but may be used in the future to
allow users to automatically extract external IDs from typed objects.
``[SOURCE]`` provides an optional way to specify the external source.
Currently there is no standard dictionary of sources.

Deprecated Annotation
"""""""""""""""""""""
::

    @deprecated [REPLACEMENT_TYPE]

The deprecated annotation is used to mark a type definition as deprecated, and
provides a structured mechanism for indicating a replacement type if one
exists.  The deprecated annotation so far is only for documentation purposes,
but may be used by the Workspace in the future to better display, list, or
query workspace objects (e.g. list all objects of a type that is not
deprecated).

Range Annotation
""""""""""""""""
::

    @range [RANGE SPECIFICATION]
    
The range annotation is associated with either a float or int typedef and
specifies the minimum and / or maximum value of the int or float. The
``[RANGE SPECIFICATION]`` is a tuple of the minimum and maximum numbers,
separated by a comma. Omit the minimum or maximum to specify an infinite
negative or positive range, respectively. Bracketing the
``[RANGE SPECIFICATION]`` with parentheses indicates the range extents are
exclusive; square brackets or no brackets indicates an inclusive range.

Examples:

=======     =============================================
Range       Explanation
=======     =============================================
0, 30       Range from 0 - 30, inclusive
[0, 30]     Range from 0 - 30, inclusive
[0, 30)     Range from 0 - 30, including 0, excluding 30
(0,         Range from 0 - +inf, excluding 0
,30]        Range from -inf - 30, including 30
=======     =============================================

Example specification::

    /*
       @range -4.5,7.6)
    */
    typedef float my_float;
    
    /*
       @range [2,10]
    */
    typedef int my_int;
    
Metadata Annotation
"""""""""""""""""""
::

    @metadata [CONTEXT] [ACTION] [as NAME]
    
The metadata annotation specifies data that an application should extract from
a TO as metadata about the TO. Typically this metadata is very small compared
to the TO and is therefore suitable for use when only a summary of the TO is
necessary for an operation. As of this writing, the WSS uses the annotation
to automatically generate user metadata for a TO.

The metadata annotation may only be associated with ``structure``
``typedef`` s. Metadata annotations on nested ``structure`` s are ignored.

``[CONTEXT]`` specifies where the metadata annotation is applicable. In the
case of the WSS, the ``[CONTEXT]`` is ``ws``. ``[CONTEXT]`` is always required.

``[ACTION]`` specifies what metadata should be extracted and any operations
to perform on said metadata. At minimum, the ``[ACTION]`` must provide the
path (dot separated) to the item of interest. Note that the path may only
proceed through ``structure`` ``typedef`` s, not ``mapping`` s or ``list`` s. A
bare path must terminate at a primitive type - either a ``string``, ``int``, or
``float``.

``[ACTION]`` s may also specify a function to apply to the item specified by
the path. Currently, the only available function is ``length()``, which may be
applied to ``list`` s, ``mapping`` s, ``tuple`` s, and ``string`` s.
``length()`` returns the number of items in a ``list``, ``mapping``, or 
``tuple``, or the length of a ``string``.

``[as NAME]`` allows specifying an optional ``NAME`` for the extracted
metadata. If a ``NAME`` is not provided, the application will use the
``[ACTION]`` string as the metadata name. The ``NAME`` is entirety of the
remainder of the line after "as".

Example::

    /* Nested structure, metadata annotations have no effect here
       Cannot provide a path into the mapping in a metadata annotation
    */
    typedef structure {
        mapping<string, string> strmap;
        int an_int;
    } InnerStruct;

    /*
       Specifies the metadata ("str" -> value of str in TO)
       @metadata ws str
       
       Specifies the metadata ("my rad string" -> value of str in TO)
       @metadata ws str as my rad string
       
       Specifies the metadata ("inner.an_int" -> value of inner.an_int in TO)
       @metadata ws inner.an_int
       
       Specifies the metadata ("length(str)" -> length of str in TO)
       @metadata ws length(str)
       
       Specifies the metadata ("num strings" -> # of items in inner.strmap)
       @metadata ws length(inner.strmap) as num strings 
       
       Note that metadata paths cannot enter outerstrmap.
    */
    typedef structure {
        InnerStruct inner;
        string str;
        mapping<string, string> outerstrmap;
    } MyStruct;
    
.. _releasetypespecexample:

Example: Release a typespec with the CLI
----------------------------------------

The following steps have been tested from a KBase cloud instance
(kbase-image-v26, https://havana.cloud.mcs.anl.gov/horizon/).

We have experienced some issues in building the WSS on machines with
out-of-date Java (tested on sdk 1.7).  If you run into errors, first make sure
your running Java is updated.

As usual, once you have started your instance, you need to check out
``dev_container`` and the necessary modules.
::

    root@mws-ws-test:/home/ubuntu# cd /kb
    
    root@mws-ws-test:/kb# git clone https://github.com/kbase/dev_container
    Cloning into 'dev_container'...
    remote: Counting objects: 639, done.
    remote: Compressing objects: 100% (600/600), done.
    remote: Total 639 (delta 374), reused 0 (delta 0)
    Receiving objects: 100% (639/639), 91.30 KiB, done.
    Resolving deltas: 100% (374/374), done.
    
    root@mws-ws-test:/kb# cd dev_container/modules/
    
    root@mws-ws-test:/kb/dev_container/modules# git clone https://github.com/kbase/jars
    Cloning into 'jars'...
    remote: Counting objects: 319, done.
    remote: Compressing objects: 100% (252/252), done.
    remote: Total 319 (delta 98), reused 0 (delta 0)
    Receiving objects: 100% (319/319), 20.94 MiB | 12.47 MiB/s, done.
    Resolving deltas: 100% (98/98), done.
    
    root@mws-ws-test:/kb/dev_container/modules# git clone https://github.com/kbase/java_common
    Cloning into 'java_common'...
    remote: Counting objects: 93, done.
    remote: Compressing objects: 100% (55/55), done.
    remote: Total 93 (delta 24), reused 0 (delta 0)
    Receiving objects: 100% (93/93), 9.95 KiB, done.
    Resolving deltas: 100% (24/24), done.
    
    root@mws-ws-test:/kb/dev_container/modules# git clone https://github.com/kbase/kbapi_common
    Cloning into 'kbapi_common'...
    remote: Counting objects: 421, done.
    remote: Compressing objects: 100% (374/374), done.
    remote: Total 421 (delta 173), reused 0 (delta 0)
    Receiving objects: 100% (421/421), 541.69 KiB, done.
    Resolving deltas: 100% (173/173), done.
    
    root@mws-ws-test:/kb/dev_container/modules# git clone https://github.com/kbase/auth
    Cloning into 'auth'...
    remote: Counting objects: 2662, done.
    remote: Compressing objects: 100% (1873/1873), done.
    remote: Total 2662 (delta 1409), reused 733 (delta 411)
    Receiving objects: 100% (2662/2662), 5.12 MiB | 9.54 MiB/s, done.
    Resolving deltas: 100% (1409/1409), done.
    
    root@mws-ws-test:/kb/dev_container/modules# git clone https://github.com/kbase/shock_service
    Cloning into 'shock_service'...
    remote: Counting objects: 1204, done.
    remote: Compressing objects: 100% (606/606), done.
    remote: Total 1204 (delta 613), reused 1074 (delta 547)
    Receiving objects: 100% (1204/1204), 10.46 MiB, done.
    Resolving deltas: 100% (613/613), done.
    
    root@mws-ws-test:/kb/dev_container/modules# git clone https://github.com/kbase/workspace_deluxe
    Cloning into 'workspace_deluxe'...
    remote: Counting objects: 9802, done.
    remote: Compressing objects: 100% (3186/3186), done.
    remote: Total 9802 (delta 6093), reused 7324 (delta 4576)
    Receiving objects: 100% (9802/9802), 17.71 MiB | 6.71 MiB/s, done.
    Resolving deltas: 100% (6093/6093), done.

    root@mws-ws-test:/kb/dev_container/modules# cd ../
    root@mws-ws-test:/kb/dev_container# ./bootstrap /kb/runtime
    root@mws-ws-test:/kb/dev_container# source user-env.sh
    root@mws-ws-test:/kb/dev_container# make

At this point make will compile and build the workspace clients and wrap the
typespec registration commands in ``/kb/dev_container/bin``. The two scripts you
need now are ``ws-typespec-register`` and ``ws-typespec-list`` which should
both be on your path.

If running make failed, you should 1) make sure your Java is up-to-date or 2)
if Shock failed to build (often due to out-of-date runtime or building on mac),
it is always safe to delete ``/kb/dev_container/modules/shock_service`` and
edit ``/kb/dev_container/workspace_deluxe/DEPENDENCIES`` and completely remove
the ``shock_service`` line. ``shock_service`` is a server-side dependency that
you don’t need, but as of yet there is no way to distinguish between client
dependencies and server dependencies.

Now test that you can run ``ws-typespec-register``::

    root@mws-ws-test:/kb/dev_container# ws-typespec-register --help

    NAME
          ws-typespec-register -- register type specifications in KIDL and release them for use

    SYNOPSIS
          ws-typespec-register [OPTIONS]
    ...

Now you can request module ownership.  First set the URL of the WSS instance
you wish to use. Below, we’ll use the continuous integration WSS.
Then call the ``ws-typespec-register`` script.  You must provide your KBase
user name and password when you register (or login using the standard
kbase-login/kbase-logout commands).
::

    root@mws-ws-test:/kb/dev_container# ws-url https://ci.berkeley.kbase.us/services/ws
    Current URL is:
    https://ci.berkeley.kbase.us/services/ws

    root@mws-ws-test:/kb/dev_container# ws-typespec-register --request MyModule --user wstester1
    Password: ********
    You have requested ownership of the Module: 'MyModule'
    This request must now be approved by the KBase team before you can register new
    type specifications for this module.  We do not yet have a notification system in place,
    so you should email whoever told you to request module ownership so that your request
    can be approved.

After you have notified a Workspace admin and your account has been approved,
you can confirm that your module is registered with the ``ws-typespec-list``
command.
::

    root@mws-ws-test:/kb/dev_container# ws-typespec-list
    File
    MyModule
    ...
    
    root@mws-ws-test:/kb/dev_container# ws-typespec-list MyModule
    Error in listing types for module 'MyModule':
    Module wasn't uploaded: MyModule

There is nothing to see because you have yet to upload your Module. You now
have full control over all the types in your Module.  So now we can try to
upload our type specification file.
::

    root@mws-ws-test:/kb/dev_container# cat MyModule.spec
    /* my module, hands off */
    module MyModule {

        typedef structure {
            string name;
            list<int> values;
        } ValueSet;

        typedef structure {
            string other_name;
            list <float> values;
        } FloatValueSet;

        funcdef getValueSet(string id) returns (ValueSet);

    };

    root@mws-ws-test:/kb/dev_container# ws-typespec-register --user wstester1 --typespec MyModule.spec --add 'ValueSet;FloatValueSet'
    Password: ********
    If this registration is committed, the following types would be updated to:
        MyModule.FloatValueSet-0.1
        MyModule.ValueSet-0.1

By default, the script will not commit the registration.  This gives you a
chance to make sure that the command was entered properly.  Make sure that
every type you think should be updated is listed.  It looks like everything is
good, so let us commit this change.  You will also get errors at this point if
your type spec file does not compile.
::

    root@mws-ws-test:/kb/dev_container# ws-typespec-register --user wstester1 --typespec MyModule.spec --add 'ValueSet;FloatValueSet' --commit
    Password: ********
    The following types have been registered:
        MyModule.FloatValueSet-0.1
        MyModule.ValueSet-0.1

You can now save objects as these types to the WSS for testing, but you will
have to specify the full type name with version number when saving.  Users will
still not be able by default to see these types because your Module has not
been released.  So next, let us release your Module so that others can find and
use your types.  You can see how users will now be able to retrieve a list of
types in your module and the typespec file you uploaded.
::

    root@mws-ws-test:/kb/dev_container# ws-typespec-register --release MyModule --user wstester1
    Password: ********
    The following types have been released to the specified version:
        MyModule.ValueSet-1.0
        MyModule.FloatValueSet-1.0

    root@mws-ws-test:/kb/dev_container# ws-typespec-list MyModule
    MyModule.FloatValueSet-1.0
    MyModule.ValueSet-1.0
    
    root@mws-ws-test:/kb/dev_container# ws-typespec-list MyModule --spec
    /* my module, hands off */
    module MyModule {

        typedef structure {
            string name;
            list<int> values;
        } ValueSet;

        typedef structure {
            string other_name;
            list <float> values;
        } FloatValueSet;

        funcdef getValueSet(string id) returns (ValueSet);

    };

The WSS versions the type definitions properly, so at any time we can upload a
new version of the type specification file and release it.  Say we now edit our
spec file, upload the new spec file, and release the module.  You’ll notice
that the types are now updated in the WSS and a new version number is
automatically assigned.  The types that you have added already will remain, so
you no longer need to specify any new typed objects to add.
::

    root@mws-ws-test:/kb/dev_container# cat MyModule.spec
    /* my module, hands off */
    module MyModule {

        /* this typed object stores a set of values */
        typedef structure {
            string name;
            string description;
            list<int> values;
        } ValueSet;

        typedef structure {
            string other_name;
            list <float> values;
        } FloatValueSet;

        funcdef getValueSet(string id) returns (ValueSet);

    };
    
    root@mws-ws-test:/kb/dev_container# ws-typespec-register --user wstester1 --typespec MyModule.spec
    Password: ********
    If this registration is committed, the following types would be updated to:
        MyModule.ValueSet-2.0

    root@mws-ws-test:/kb/dev_container# ws-typespec-register --user wstester1 --typespec MyModule.spec --commit
    Password: ********
    The following types have been registered:
        MyModule.ValueSet-2.0

    root@mws-ws-test:/kb/dev_container# ws-typespec-list MyModule
    MyModule.FloatValueSet-1.0
    MyModule.ValueSet-1.0

The new type has not been released yet, so again, although you can use it by
specifying the exact version number, but users will not be able to see your
type.  Let’s release the module again, at which point users will be able to see
the latest version.::

    root@mws-ws-test:/kb/dev_container# ws-typespec-register --release MyModule --user wstester1
    Password: ********
    The following types have been released to the specified version:
        MyModule.ValueSet-2.0
        MyModule.FloatValueSet-1.0
    
    root@mws-ws-test:/kb/dev_container# ws-typespec-list MyModule
    MyModule.FloatValueSet-1.0
    MyModule.ValueSet-2.0

    root@mws-ws-test:/kb/dev_container# ws-typespec-list MyModule.ValueSet
    LATEST VERSION: MyModule.ValueSet-2.0
    DESCRIPTION:
    this typed object stores a set of values



